### 1. TCP (Transmission Control Protocol)

TCP 的核心哲學是：**「寧可慢，絕對不能錯。」**
- **建立連線（三向交握）：** 傳資料前，一定要先確認對方在不在。
    1. 我：你在嗎？ (SYN)
    2. 對方：我在，你準備好了嗎？ (SYN/ACK)
    3. 我：準備好了，我要傳囉！ (ACK)
- **確認機制 (ACK)：** 每傳一箱貨，對方都要回傳「我收到了第 X 箱」。
- **重傳機制：** 如果有一箱貨在路上掉了（丟包），TCP 會發現對方的收據少了一張，然後**重新寄送**那一箱。
- **排序功能：** 資料拆成很多份傳送，如果抵達順序是 1 $\rightarrow$ 3 $\rightarrow$ 2，TCP 會在目的地重新排好再交給軟體。

### 2. UDP (User Datagram Protocol)

UDP 的核心哲學是：**「我只管衝，沒收到算你倒楣。」**
- **不建立連線（無狀態）：** 像丟飛鏢一樣，抓起資料就往目標 IP 丟，不管對方有沒有開機。
- **沒確認機制：** 傳出去就結束了，對方收不收到、順序對不對，UDP 統統不管。
- **極低延遲：** 因為不需要等對方回覆「我收到了」，速度極快，負擔極輕。

### VPN補充
### 1. 致命的「TCP 熔斷效能」 (TCP Meltdown)

這是最主要的原因。假設你正在 VPN 隧道裡傳輸一個檔案（使用 TCP），而你的 VPN 隧道本身也是 TCP：
- **狀況：** 底層的網路環境（例如公共 Wi-Fi）稍微抖動了一下，掉了一個封包。
- **反應 A（外部 TCP）：** VPN 隧道的 TCP 發現掉包了，開始等待並嘗試重傳。
- **反應 B（內部 TCP）：** 你傳輸檔案的那個 TCP 發現「怎麼沒收到回應？」，它不知道是 VPN 在重傳，它以為是自己掉包了，於是**也開始重傳**。
- **結果：** 兩層 TCP 同時在搶著重傳與確認，導致頻寬被重複的垃圾封包塞滿，延遲（Latency）會呈指數級飆升。這就是所謂的 **TCP Meltdown**。

> **解決方案：** 如果 VPN 隧道使用 **UDP**，它只負責把加密包丟過去。如果掉包了，讓內層的 TCP 自己去發現並重傳就好。**「一層管理，一層跑路」** 才是最高效的。

### 2. 握手（Handshake）的開銷

- **TCP：** 建立連線要三向交握。如果你在 VPN 斷線重連，TCP 必須重頭來過。
- **UDP：** 它是「無狀態」的。像 **WireGuard** 這種現代 VPN，平時不傳資料時根本不發包（安靜得像不存在）。當有資料要傳時，抓起來就丟，這讓行動裝置在切換 Wi-Fi 和 5G 訊號時，VPN 連線幾乎能「無感」切換，不會卡在 TCP 的重新連線流程。

### UDP劫持補充
- **DNS 劫持 (UDP Port 53)：** 當你查詢 `www.google.com` 時，學校防火牆攔截了你的 UDP 請求，並偽造一個假的 UDP 回應給你，告訴你 Google 的 IP 是 `127.0.0.1`（讓你上不去）。這就是利用了 **UDP 沒經過加密且不驗證身分** 的弱點。